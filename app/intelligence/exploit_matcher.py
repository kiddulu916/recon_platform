"""
Exploit Matching System

Maintains synchronized exploit database and matches vulnerabilities to available exploits.
Considers reliability, platform requirements, and potential impact.
"""

import json
import asyncio
from typing import List, Dict, Optional, Any
from datetime import datetime, timedelta
import structlog
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
import aiohttp

from app.models.vulnerability import Vulnerability, ExploitDatabase, CVEDatabase

logger = structlog.get_logger()


class ExploitMatcher:
    """
    Matches vulnerabilities to available exploits

    Features:
    - CVE to exploit mapping
    - Exploit database synchronization
    - Reliability and impact assessment
    - Prerequisite checking
    """

    def __init__(self, config):
        self.config = config
        self.logger = logger.bind(component="exploit_matcher")
        self.exploit_sources = {
            "exploitdb": "https://www.exploit-db.com/",
            "packetstorm": "https://packetstormsecurity.com/",
        }

    async def match_exploits(
        self,
        vulnerability: Vulnerability,
        db_session: AsyncSession
    ) -> List[Dict[str, Any]]:
        """
        Find available exploits for a vulnerability

        Args:
            vulnerability: Vulnerability to match
            db_session: Database session

        Returns:
            List of matched exploits with metadata
        """
        matched_exploits = []

        # Match by CVE ID
        if vulnerability.cve_id:
            cve_exploits = await self._match_by_cve(vulnerability.cve_id, db_session)
            matched_exploits.extend(cve_exploits)

        # Match by affected component and version
        if vulnerability.affected_component and vulnerability.affected_version:
            component_exploits = await self._match_by_component(
                vulnerability.affected_component,
                vulnerability.affected_version,
                db_session
            )
            matched_exploits.extend(component_exploits)

        # Match by vulnerability type
        type_exploits = await self._match_by_type(
            vulnerability.type,
            vulnerability.affected_component,
            db_session
        )
        matched_exploits.extend(type_exploits)

        # Deduplicate and score
        unique_exploits = self._deduplicate_exploits(matched_exploits)
        scored_exploits = self._score_exploits(unique_exploits, vulnerability)

        # Update vulnerability with exploit information
        if scored_exploits:
            vulnerability.exploit_available = True
            vulnerability.exploitable = any(e["score"] > 0.7 for e in scored_exploits)

            # Link best exploit
            best_exploit = scored_exploits[0]
            vulnerability.exploit_url = best_exploit.get("url")
            vulnerability.exploitation_complexity = best_exploit.get("complexity", "Unknown")

            await db_session.commit()

        return scored_exploits

    async def _match_by_cve(
        self,
        cve_id: str,
        db_session: AsyncSession
    ) -> List[Dict]:
        """Match exploits by CVE ID"""
        exploits = []

        try:
            result = await db_session.execute(
                select(ExploitDatabase).where(
                    ExploitDatabase.cve_ids.like(f'%{cve_id}%')
                )
            )
            exploit_records = result.scalars().all()

            for exploit in exploit_records:
                exploits.append(self._exploit_to_dict(exploit))

        except Exception as e:
            self.logger.warning("CVE exploit matching failed", cve_id=cve_id, error=str(e))

        return exploits

    async def _match_by_component(
        self,
        component: str,
        version: str,
        db_session: AsyncSession
    ) -> List[Dict]:
        """Match exploits by affected component and version"""
        exploits = []

        try:
            # Extract product name from component
            product = component.split(':')[0] if ':' in component else component

            result = await db_session.execute(
                select(ExploitDatabase).where(
                    and_(
                        ExploitDatabase.application.like(f'%{product}%'),
                        ExploitDatabase.version.like(f'%{version}%')
                    )
                ).limit(50)
            )
            exploit_records = result.scalars().all()

            for exploit in exploit_records:
                exploits.append(self._exploit_to_dict(exploit))

        except Exception as e:
            self.logger.warning("Component exploit matching failed", error=str(e))

        return exploits

    async def _match_by_type(
        self,
        vuln_type: str,
        component: Optional[str],
        db_session: AsyncSession
    ) -> List[Dict]:
        """Match exploits by vulnerability type"""
        exploits = []

        # Map vulnerability types to exploit types
        type_mapping = {
            "sqli": "remote",
            "xss": "remote",
            "rce": "remote",
            "lfi": "remote",
            "xxe": "remote",
            "ssrf": "remote",
        }

        exploit_type = type_mapping.get(vuln_type.lower())
        if not exploit_type:
            return exploits

        try:
            query = select(ExploitDatabase).where(
                ExploitDatabase.exploit_type == exploit_type
            )

            if component:
                product = component.split(':')[0]
                query = query.where(ExploitDatabase.application.like(f'%{product}%'))

            query = query.limit(20)

            result = await db_session.execute(query)
            exploit_records = result.scalars().all()

            for exploit in exploit_records:
                exploits.append(self._exploit_to_dict(exploit))

        except Exception as e:
            self.logger.warning("Type-based exploit matching failed", error=str(e))

        return exploits

    def _exploit_to_dict(self, exploit: ExploitDatabase) -> Dict:
        """Convert ExploitDatabase record to dictionary"""
        return {
            "exploit_id": exploit.exploit_id,
            "title": exploit.title,
            "description": exploit.description,
            "source": exploit.source,
            "url": exploit.url,
            "cve_ids": json.loads(exploit.cve_ids or "[]"),
            "platform": exploit.platform,
            "application": exploit.application,
            "version": exploit.version,
            "exploit_type": exploit.exploit_type,
            "reliability": exploit.reliability,
            "impact": exploit.impact,
            "authentication_required": exploit.authentication_required,
            "prerequisites": json.loads(exploit.prerequisites or "[]"),
            "complexity": exploit.complexity,
            "has_code": exploit.has_code,
            "code_language": exploit.code_language,
            "verified": exploit.verified,
        }

    def _deduplicate_exploits(self, exploits: List[Dict]) -> List[Dict]:
        """Remove duplicate exploits"""
        seen = set()
        unique = []

        for exploit in exploits:
            exploit_id = exploit.get("exploit_id")
            if exploit_id and exploit_id not in seen:
                seen.add(exploit_id)
                unique.append(exploit)

        return unique

    def _score_exploits(
        self,
        exploits: List[Dict],
        vulnerability: Vulnerability
    ) -> List[Dict]:
        """
        Score exploits based on reliability, impact, and context

        Scoring factors:
        - Reliability (0.3 weight)
        - Impact severity (0.25 weight)
        - Complexity (0.15 weight)
        - Verification status (0.15 weight)
        - Code availability (0.1 weight)
        - Platform match (0.05 weight)
        """
        scored = []

        for exploit in exploits:
            score = 0.0

            # Reliability score (0-0.3)
            reliability_map = {
                "Excellent": 0.3,
                "Good": 0.25,
                "Average": 0.15,
                "Low": 0.05
            }
            score += reliability_map.get(exploit.get("reliability", ""), 0.1)

            # Impact score (0-0.25)
            impact = exploit.get("impact", "").lower()
            if "code execution" in impact or "rce" in impact:
                score += 0.25
            elif "privilege escalation" in impact:
                score += 0.20
            elif "information disclosure" in impact:
                score += 0.10
            else:
                score += 0.05

            # Complexity score (0-0.15, inverse of complexity)
            complexity_map = {
                "Low": 0.15,
                "Medium": 0.10,
                "High": 0.05
            }
            score += complexity_map.get(exploit.get("complexity", ""), 0.05)

            # Verification bonus (0-0.15)
            if exploit.get("verified"):
                score += 0.15
            else:
                score += 0.05

            # Code availability bonus (0-0.1)
            if exploit.get("has_code"):
                score += 0.1

            # Platform match bonus (0-0.05)
            # Simplified - in production, match against actual platform
            score += 0.05

            # Prerequisites penalty
            prereqs = exploit.get("prerequisites", [])
            if len(prereqs) > 2:
                score *= 0.8  # Reduce score for complex prerequisites

            # Authentication penalty
            if exploit.get("authentication_required"):
                score *= 0.9

            exploit["score"] = score
            exploit["match_reason"] = self._get_match_reason(exploit, vulnerability)
            scored.append(exploit)

        # Sort by score descending
        scored.sort(key=lambda x: x["score"], reverse=True)

        return scored

    def _get_match_reason(self, exploit: Dict, vulnerability: Vulnerability) -> str:
        """Generate human-readable match reason"""
        reasons = []

        if vulnerability.cve_id and vulnerability.cve_id in exploit.get("cve_ids", []):
            reasons.append(f"CVE match ({vulnerability.cve_id})")

        if vulnerability.affected_component and exploit.get("application"):
            if vulnerability.affected_component.lower() in exploit.get("application", "").lower():
                reasons.append("Component match")

        if vulnerability.type and exploit.get("exploit_type"):
            reasons.append("Type match")

        return ", ".join(reasons) if reasons else "General match"

    async def sync_exploit_database(
        self,
        db_session: AsyncSession,
        sources: Optional[List[str]] = None
    ) -> Dict[str, int]:
        """
        Synchronize exploit database from external sources

        Args:
            db_session: Database session
            sources: List of sources to sync (default: all)

        Returns:
            Dictionary with sync statistics
        """
        self.logger.info("Starting exploit database sync")

        stats = {
            "exploits_added": 0,
            "exploits_updated": 0,
            "errors": 0
        }

        sources = sources or list(self.exploit_sources.keys())

        for source in sources:
            try:
                if source == "exploitdb":
                    source_stats = await self._sync_exploitdb(db_session)
                    stats["exploits_added"] += source_stats["added"]
                    stats["exploits_updated"] += source_stats["updated"]

                # Add more sources as needed

            except Exception as e:
                self.logger.error(f"Failed to sync {source}", error=str(e))
                stats["errors"] += 1

        self.logger.info("Exploit database sync complete", **stats)
        return stats

    async def _sync_exploitdb(self, db_session: AsyncSession) -> Dict[str, int]:
        """Sync exploits from Exploit-DB"""
        # This is a placeholder - in production, implement actual API integration
        # or CSV parsing from ExploitDB's public database

        stats = {"added": 0, "updated": 0}

        # Example: Add some well-known exploits
        sample_exploits = [
            {
                "exploit_id": "EDB-50383",
                "title": "Apache HTTP Server 2.4.49 - Path Traversal & RCE",
                "description": "Path traversal and remote code execution",
                "source": "ExploitDB",
                "url": "https://www.exploit-db.com/exploits/50383",
                "cve_ids": ["CVE-2021-41773", "CVE-2021-42013"],
                "platform": "Linux",
                "application": "Apache HTTP Server",
                "version": "2.4.49",
                "exploit_type": "remote",
                "reliability": "Excellent",
                "impact": "Code Execution",
                "authentication_required": False,
                "complexity": "Low",
                "has_code": True,
                "code_language": "Python",
                "verified": True,
            }
        ]

        for exploit_data in sample_exploits:
            try:
                # Check if exists
                result = await db_session.execute(
                    select(ExploitDatabase).where(
                        ExploitDatabase.exploit_id == exploit_data["exploit_id"]
                    )
                )
                existing = result.scalar_one_or_none()

                if existing:
                    # Update
                    for key, value in exploit_data.items():
                        if isinstance(value, list):
                            value = json.dumps(value)
                        setattr(existing, key, value)
                    stats["updated"] += 1
                else:
                    # Create new
                    exploit = ExploitDatabase(
                        **{k: json.dumps(v) if isinstance(v, list) else v
                           for k, v in exploit_data.items()}
                    )
                    db_session.add(exploit)
                    stats["added"] += 1

            except Exception as e:
                self.logger.warning("Failed to sync exploit", exploit_id=exploit_data.get("exploit_id"), error=str(e))

        await db_session.commit()
        return stats

    async def sync_cve_database(
        self,
        db_session: AsyncSession,
        days_back: int = 30
    ) -> Dict[str, int]:
        """
        Synchronize CVE database from NVD

        Args:
            db_session: Database session
            days_back: How many days back to sync

        Returns:
            Sync statistics
        """
        self.logger.info("Starting CVE database sync", days_back=days_back)

        stats = {
            "cves_added": 0,
            "cves_updated": 0,
            "errors": 0
        }

        # In production, integrate with NVD API
        # For now, placeholder for demonstration

        self.logger.info("CVE database sync complete", **stats)
        return stats
