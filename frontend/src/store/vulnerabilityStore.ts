import { create } from 'zustand';
import type { Vulnerability } from '../types';
import apiService from '../services/api';

interface VulnerabilityState {
  vulnerabilities: Vulnerability[];
  currentVulnerability: Vulnerability | null;
  isLoading: boolean;
  error: string | null;

  // Filters
  filters: {
    severity: string[];
    verified: boolean | null;
    falsePositive: boolean | null;
  };

  // Actions
  fetchVulnerabilities: (domainId: number) => Promise<void>;
  fetchVulnerability: (id: number) => Promise<void>;
  verifyVulnerability: (id: number, verified_by: string, comments?: string) => Promise<void>;
  markFalsePositive: (id: number, verified_by: string, comments?: string) => Promise<void>;
  setFilters: (filters: Partial<VulnerabilityState['filters']>) => void;
  getFilteredVulnerabilities: () => Vulnerability[];
  clearError: () => void;
}

export const useVulnerabilityStore = create<VulnerabilityState>((set, get) => ({
  vulnerabilities: [],
  currentVulnerability: null,
  isLoading: false,
  error: null,

  filters: {
    severity: [],
    verified: null,
    falsePositive: null,
  },

  fetchVulnerabilities: async (domainId: number) => {
    set({ isLoading: true, error: null });
    try {
      const vulnerabilities = await apiService.getVulnerabilities(domainId);
      set({ vulnerabilities, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
    }
  },

  fetchVulnerability: async (id: number) => {
    set({ isLoading: true, error: null });
    try {
      const vulnerability = await apiService.getVulnerability(id);
      set({ currentVulnerability: vulnerability, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
    }
  },

  verifyVulnerability: async (id: number, verified_by: string, comments?: string) => {
    set({ isLoading: true, error: null });
    try {
      const updated = await apiService.verifyVulnerability(id, {
        is_verified: true,
        verified_by,
        comments,
      });
      set((state) => ({
        vulnerabilities: state.vulnerabilities.map((v) => (v.id === id ? updated : v)),
        currentVulnerability:
          state.currentVulnerability?.id === id ? updated : state.currentVulnerability,
        isLoading: false,
      }));
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
    }
  },

  markFalsePositive: async (id: number, verified_by: string, comments?: string) => {
    set({ isLoading: true, error: null });
    try {
      const updated = await apiService.markFalsePositive(id, { verified_by, comments });
      set((state) => ({
        vulnerabilities: state.vulnerabilities.map((v) => (v.id === id ? updated : v)),
        currentVulnerability:
          state.currentVulnerability?.id === id ? updated : state.currentVulnerability,
        isLoading: false,
      }));
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
    }
  },

  setFilters: (filters) => {
    set((state) => ({
      filters: { ...state.filters, ...filters },
    }));
  },

  getFilteredVulnerabilities: () => {
    const { vulnerabilities, filters } = get();
    return vulnerabilities.filter((v) => {
      if (filters.severity.length > 0 && !filters.severity.includes(v.severity)) {
        return false;
      }
      if (filters.verified !== null && v.is_verified !== filters.verified) {
        return false;
      }
      if (filters.falsePositive !== null && v.is_false_positive !== filters.falsePositive) {
        return false;
      }
      return true;
    });
  },

  clearError: () => set({ error: null }),
}));
